# auth-service v0.2.5 Complete Source Code Review
# Generated for ChatGPT code review and requirements validation
# Branch: auth-service-v0.2.5
# Features: R5 Enhanced OIDC + v0.2.5 Identity Management

## Summary
- R5 Enhanced OAuth2/OIDC Provider with enterprise security features
- v0.2.5 Complete Identity Management (register, verify, reset password, etc.)
- Multi-tenant architecture with proper isolation
- bcrypt password hashing with legacy migration support
- Comprehensive audit logging and security controls

## Files Included


===== BEGIN src/controllers/oidc.ts =====

// src/controllers/oidc.ts
import { Request, Response } from 'express';
import { env } from '../config/env.js';
import { buildJwksWithEtag, ensureOneActiveKey } from '../infra/keystore.js';
import { prisma } from '../infra/prisma.js';
import { issueRefreshFamily, rotateRefreshToken, revokeFamilyByOldReuse, signAccessToken, signIdToken } from '../services/token.js';
import { validateClientTenantAccess } from '../services/tenant.js';
import { audit } from '../middleware/audit.js';
import { importJWK, jwtVerify } from 'jose';
import crypto from 'crypto';
import bcrypt from 'bcryptjs';

// ===== Discovery =====
export async function discovery(_req: Request, res: Response){
  const base = env.issuerUrl.replace(/\/+$/, '');
  res.json({
    issuer: base,
    authorization_endpoint: `${base}/oauth/authorize`,
    token_endpoint: `${base}/oauth/token`,
    jwks_uri: `${base}/jwks.json`,
    userinfo_endpoint: `${base}/userinfo`,
    revocation_endpoint: `${base}/oauth/revoke`,
    grant_types_supported: ['authorization_code','refresh_token'],
    response_types_supported: ['code'],
    id_token_signing_alg_values_supported: ['RS256'],
    token_endpoint_auth_methods_supported: ['none','client_secret_post','client_secret_basic'],
    code_challenge_methods_supported: ['S256']
  });
}

// ===== JWKS with ETag =====
export async function jwks(req: Request, res: Response){
  await ensureOneActiveKey();
  const { jwks, etag } = await buildJwksWithEtag();
  const inm = req.header('if-none-match') || req.header('If-None-Match');
  if (inm && inm === etag) {
    return res.status(304)
      .set('Cache-Control', `public, max-age=${env.jwksMaxAgeSec}`)
      .set('ETag', etag).end();
  }
  return res.status(200)
    .set('Cache-Control', `public, max-age=${env.jwksMaxAgeSec}`)
    .set('ETag', etag).json(jwks);
}

// ===== 简化的登录与授权（保持与 R4 一致的行为） =====
export async function getLogin(_req: Request, res: Response){
  res.type('html').sendFile('login.html', { root: 'src/views' });
}

export async function postLogin(req: Request, res: Response){
  const { email, password, return_to } = req.body;
  audit('login_attempt', { email, ip: req.ip });
  
  const u = await prisma.user.findUnique({ where: { email }});
  if (!u) {
    audit('login_fail', { email, reason: 'user_not_found' });
    return res.status(401).send('Invalid credentials');
  }
  
  let passwordValid = false;
  
  // 优先使用 bcrypt hash 验证
  if (u.passwordHash) {
    passwordValid = await bcrypt.compare(password, u.passwordHash);
  } 
  // 兜底：如果还有 legacy 明文密码且 hash 为空，临时允许并迁移
  else if (u.password) {
    passwordValid = (password === u.password);
    if (passwordValid) {
      // 自动迁移：将明文密码升级为哈希
      const hash = await bcrypt.hash(password, 10); // 使用默认轮数
      await prisma.user.update({
        where: { id: u.id },
        data: { passwordHash: hash, password: null }
      });
      audit('password_auto_migrated', { userId: u.id, email });
    }
  }
  
  if (!passwordValid) {
    audit('login_fail', { email, reason: 'invalid_password' });
    return res.status(401).send('Invalid credentials');
  }
  
  // 写入轻量 session（假设你已有 session 中间件；若没有，用签名 cookie）
  (req as any).session = { user: { id: u.id, email: u.email, tenantId: u.tenantId, roles: u.roles }};
  audit('login_success', { email, userId: u.id, tenantId: u.tenantId });
  
  const redirect = return_to || '/';
  return res.redirect(302, redirect);
}

export async function getAuthorize(req: Request, res: Response){
  const u = (req as any).session?.user;
  if (!u){
    const return_to = encodeURIComponent(req.originalUrl);
    return res.redirect(302, `/login?return_to=${return_to}`);
  }
  // 生成一次性授权码
  const { client_id, redirect_uri, scope, state, code_challenge, code_challenge_method, nonce } = req.query as any;
  if (!client_id || !redirect_uri || !code_challenge) return res.status(400).send('invalid_request');

  const codeId = crypto.randomUUID();
  await prisma.authorizationCode.create({
    data: {
      id: codeId,
      clientId: client_id,
      redirectUri: redirect_uri,
      codeChallenge: code_challenge,
      codeChallengeMethod: code_challenge_method || 'S256',
      scope: (scope || '').toString(),
      state: (state || '').toString(),
      nonce: (nonce || '').toString(),
      subjectUserId: u.id,
      tenantId: u.tenantId,
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 5*60*1000),
      used: false
    }
  });
  
  audit('authorize', { clientId: client_id, userId: u.id, scope });
  
  const r = new URL(redirect_uri);
  r.searchParams.set('code', codeId);
  if (state) r.searchParams.set('state', state);
  return res.redirect(302, r.toString());
}

// ===== Token Endpoint =====
export async function token(req: Request, res: Response){
  const { grant_type } = req.body || {};
  try{
    if (grant_type === 'authorization_code'){
      const { code, code_verifier, client_id, redirect_uri } = req.body;
      if (!code || !code_verifier || !client_id || !redirect_uri) {
        return res.status(400).json({ error: 'invalid_request' });
      }
      const c = await prisma.authorizationCode.findUnique({ where: { id: code }});
      if (!c || c.used || new Date(c.expiresAt) < new Date()){
        return res.status(400).json({ error: 'invalid_grant' });
      }

      // ✅ 必修1：授权码绑定校验，防止换绑/窃用
      if (c.clientId !== client_id || c.redirectUri !== redirect_uri) {
        audit('token_denied', {
          clientId: client_id, tenantId: c.tenantId, reason: 'code_binding_mismatch'
        });
        return res.status(400).json({ error: 'invalid_grant' });
      }

      // 校验 PKCE (S256)
      const challenge = require('crypto').createHash('sha256').update(code_verifier).digest('base64')
        .replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
      if (c.codeChallengeMethod !== 'S256' || challenge !== c.codeChallenge){
        return res.status(400).json({ error: 'invalid_grant' });
      }
      // 强校验：client_id 是否允许在该 tenant 下使用
      const isClientAllowed = await validateClientTenantAccess(client_id, c.tenantId!);
      if (!isClientAllowed) {
        audit('token_denied', { clientId: client_id, tenantId: c.tenantId, reason: 'unauthorized_client_tenant' });
        return res.status(401).json({ error: 'unauthorized_client_tenant' });
      }
      
      // 多租户与受众：从 TenantClient 上下文兜底 aud
      const tc = await prisma.tenantClient.findFirst({ where: { clientId: client_id, tenantId: c.tenantId || undefined }});
      const aud = tc?.defaultAud ?? `${env.defaultAudPrefix}:${c.tenantId}`;
      const scopes = (c.scope || '').split(/\s+/).filter(Boolean);
      
      // 发 RT 家族
      const { refreshId } = await issueRefreshFamily({ userId: c.subjectUserId!, clientId: client_id, tenantId: c.tenantId! });

      // AT 面向 API（aud = API 受众）
      const at = await signAccessToken({
        sub: c.subjectUserId!, tenant_id: c.tenantId!, roles: [], scopes, aud
      });
      
      // ✅ 必修2&3：ID Token 面向客户端 aud=client_id，并包含 nonce（若存在）
      const idToken = await signIdToken({
        sub: c.subjectUserId!, 
        tenant_id: c.tenantId!, 
        client_id, 
        nonce: c.nonce || undefined
      });

      await prisma.authorizationCode.update({ where: { id: code }, data: { used: true, usedAt: new Date() }});
      
      audit('token_issue', { clientId: client_id, userId: c.subjectUserId, grantType: grant_type });

      return res.json({
        access_token: at,
        token_type: 'Bearer',
        expires_in: Number(env.accessTtlSec),
        refresh_token: refreshId,
        id_token: idToken
      });
    }

    if (grant_type === 'refresh_token'){
      const { refresh_token } = req.body;
      try{
        const rotated = await rotateRefreshToken(refresh_token);
        
        // 从用户信息获取真实的tenant_id
        let tenantId: string | null = null;
        if (rotated.subject.userId) {
          const user = await prisma.user.findUnique({ 
            where: { id: rotated.subject.userId },
            select: { tenantId: true }
          });
          tenantId = user?.tenantId ?? null;
        }
        
        if (!tenantId) {
          audit('token_refresh_failed', { refreshTokenId: refresh_token, reason: 'no_tenant_found' });
          return res.status(400).json({ error: 'invalid_refresh_subject' });
        }
        
        // 根据租户计算受众（避免跨租户误发）
        const aud = `${env.defaultAudPrefix}:${tenantId}`;
        
        const at = await signAccessToken({
          sub: (rotated.subject.userId ?? rotated.subject.deviceId)!,
          tenant_id: tenantId,
          roles: [], // 刷新场景通常不扩权
          scopes: [], // 刷新场景通常不扩权
          device_id: rotated.subject.deviceId ?? null,
          aud
        });
        
        audit('token_refresh', { refreshTokenId: refresh_token, newRefreshTokenId: rotated.newId, tenantId });
        
        return res.json({
          access_token: at,
          token_type: 'Bearer',
          expires_in: Number(env.accessTtlSec),
          refresh_token: rotated.newId
        });
      }catch(e:any){
        if (e?.code === 'reuse') {            // 只有"复用"才全家族封禁
          await revokeFamilyByOldReuse(refresh_token);
          audit('refresh_reuse', { refreshTokenId: refresh_token });
          return res.status(401).json({ error: 'invalid_refresh_token' });
        }
        if (['expired','inactive','not_found'].includes(e?.code)) {
          audit('token_refresh_failed', { refreshTokenId: refresh_token, reason: e.code });
          return res.status(401).json({ error: 'invalid_refresh_token' });
        }
        throw e;
      }
    }

    return res.status(400).json({ error: 'unsupported_grant_type' });

  }catch(e:any){
    return res.status(500).json({ error: 'server_error', detail: e?.message });
  }
}

// ===== UserInfo =====
export async function userinfo(req: Request, res: Response){
  // 由 requireBearer 验证并注入的 claims
  const claims = (req as any).claims || {};
  const { sub, tenant_id, roles, scopes = [], acr } = claims;

  const s: string[] = Array.isArray(scopes) ? scopes : [];
  if (!s.includes('openid')) {
    return res.status(403).json({ error: 'insufficient_scope' });
  }

  res.json({
    sub,
    tenant_id,
    roles: roles ?? [],
    scopes: s,
    acr: acr ?? 'normal'
  });
}

// ===== Revoke =====
export async function revoke(req: Request, res: Response){
  const { refresh_token } = req.body || {};
  if (!refresh_token) return res.status(400).json({ error: 'invalid_request' });
  
  await prisma.refreshToken.updateMany({
    where: { OR: [{ id: refresh_token }, { familyId: refresh_token }] },
    data: { status: 'revoked', revokedAt: new Date(), revokeReason: 'manual' }
  });
  
  audit('revoke', { refreshTokenId: refresh_token });
  res.json({ success: true });
}

// ===== Introspect（要求 Basic Auth 并验证JWT）=====
export async function introspect(req: Request, res: Response){
  // 1) Client authentication（Basic Auth）
  const auth = req.header('authorization') || '';
  const m = auth.match(/^Basic\s+(.+)$/i);
  if (!m) {
    audit('introspect', { result: 'no_auth' });
    return res.json({ active: false });
  }
  const s = Buffer.from(m[1], 'base64').toString('utf8');
  const [cid, secret] = s.split(':');
  if (cid !== env.introspectClientId || secret !== env.introspectClientSecret){
    audit('introspect', { clientId: cid, result: 'invalid_client' });
    return res.json({ active: false });
  }

  // 2) 获取要验证的token
  const token = (req.body?.token as string) || '';
  if (!token) {
    audit('introspect', { clientId: cid, result: 'no_token' });
    return res.json({ active: false });
  }

  try {
    // 3) 解析JWT header获取kid
    const [headerB64] = token.split('.');
    if (!headerB64) {
      audit('introspect', { clientId: cid, result: 'invalid_token_format' });
      return res.json({ active: false });
    }
    
    const header = JSON.parse(Buffer.from(headerB64, 'base64url').toString());
    const kid = header.kid as string | undefined;
    if (!kid) {
      audit('introspect', { clientId: cid, result: 'no_kid' });
      return res.json({ active: false });
    }

    // 4) 根据kid查找公钥
    const keyRecord = await prisma.key.findUnique({ 
      where: { kid },
      select: { publicJwk: true, status: true }
    });
    
    if (!keyRecord || keyRecord.status === 'retired') {
      audit('introspect', { clientId: cid, kid, result: 'key_not_found_or_retired' });
      return res.json({ active: false });
    }

    // 5) 使用jose验证JWT
    const publicKey = await importJWK(keyRecord.publicJwk as any, 'RS256');
    const { payload: decoded } = await jwtVerify(token, publicKey, { 
      algorithms: ['RS256'],
      clockTolerance: 30  // ✅ 30 秒时钟容错
    });

    // 6) 返回RFC 7662标准格式的响应
    audit('introspect', { clientId: cid, kid, sub: decoded.sub, result: 'active' });
    return res.json({
      active: true,
      iss: decoded.iss,
      sub: decoded.sub,
      aud: decoded.aud,
      iat: decoded.iat,
      exp: decoded.exp,
      jti: decoded.jti,
      scope: Array.isArray((decoded as any).scopes) ? (decoded as any).scopes.join(' ') : undefined,
      tenant_id: (decoded as any).tenant_id,
      acr: (decoded as any).acr
    });

  } catch (error) {
    // JWT验证失败（过期、签名错误等）
    audit('introspect', { clientId: cid, result: 'token_invalid', error: error instanceof Error ? error.message : String(error) });
    return res.json({ active: false });
  }
}

// ===== Logout =====
export async function logout(req: Request, res: Response){
  (req as any).session = null;
  audit('logout', { ip: req.ip });
  res.redirect('/');
}
===== END src/controllers/oidc.ts =====


===== BEGIN src/controllers/identity.ts =====

import { Request, Response } from 'express';
import { prisma } from '../infra/prisma.js';
import { env } from '../config/env.js';
import bcrypt from 'bcryptjs';
import crypto from 'crypto';
import { sendMailDev } from '../services/mailer.js';
import { audit } from '../middleware/audit.js';

function minutesFromNow(mins: number) { 
  return new Date(Date.now() + mins * 60 * 1000); 
}

function buildUrl(base: string, path: string, params: Record<string, string>) {
  const u = new URL(path, base);
  for (const [k, v] of Object.entries(params)) {
    u.searchParams.set(k, v);
  }
  return u.toString();
}

export async function register(req: Request, res: Response) {
  // TODO: 速率限制
  const { email, password, tenant_id } = req.body ?? {};
  
  // 基本入参校验
  if (!email || !password) {
    audit('register_invalid_request', { ip: req.ip });
    return res.status(400).json({ error: 'invalid_request' });
  }
  
  // 简单邮箱格式验证
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    audit('register_invalid_email', { email, ip: req.ip });
    return res.status(400).json({ error: 'invalid_email' });
  }
  
  try {
    const exists = await prisma.user.findUnique({ where: { email } });
    if (exists) {
      // 不暴露用户存在性
      audit('register_conflict', { email, ip: req.ip });
      return res.status(200).json({ ok: true });
    }
    
    const hash = await bcrypt.hash(password, env.passwordHashRounds);
    const user = await prisma.user.create({
      data: {
        email,
        passwordHash: hash,
        tenantId: tenant_id || env.defaultTenantId,
        roles: ['user'],
      }
    });
    
    // 发邮箱验证
    const token = crypto.randomUUID();
    await prisma.emailVerificationToken.create({
      data: {
        userId: user.id,
        token,
        expiresAt: minutesFromNow(30),
      }
    });
    
    const url = buildUrl(env.issuerUrl, '/verify', { token });
    await sendMailDev(user.email, 'Verify your email', `点击验证：<a href="${url}">${url}</a>`);
    
    audit('register', { userId: user.id, tenantId: user.tenantId, ip: req.ip });
    return res.json({ ok: true });
    
  } catch (error) {
    audit('register_error', { email, error: error instanceof Error ? error.message : String(error), ip: req.ip });
    return res.status(500).json({ error: 'server_error' });
  }
}

export async function verifyEmail(req: Request, res: Response) {
  // 支持 GET/POST，GET 用于点击链接
  const token = (req.method === 'GET' ? req.query.token : req.body?.token) as string | undefined;
  
  if (!token) {
    audit('verify_invalid_request', { ip: req.ip });
    return res.status(400).json({ error: 'invalid_request' });
  }
  
  try {
    const t = await prisma.emailVerificationToken.findUnique({ 
      where: { token },
      include: { user: true }
    });
    
    if (!t || t.status !== 'pending' || t.expiresAt < new Date()) {
      audit('verify_fail', { token, ip: req.ip });
      return res.status(400).json({ error: 'invalid_token' });
    }
    
    await prisma.$transaction([
      prisma.user.update({ 
        where: { id: t.userId }, 
        data: { emailVerifiedAt: new Date() }
      }),
      prisma.emailVerificationToken.update({ 
        where: { token }, 
        data: { status: 'used', usedAt: new Date() }
      })
    ]);
    
    audit('verify_success', { userId: t.userId, email: t.user.email, ip: req.ip });
    
    // GET 返回简单 HTML，POST 返回 JSON
    if (req.method === 'GET') { 
      return res.type('html').send('<h1>邮箱已验证</h1><p>您的邮箱已成功验证！</p>'); 
    }
    return res.json({ ok: true });
    
  } catch (error) {
    audit('verify_error', { token, error: error instanceof Error ? error.message : String(error), ip: req.ip });
    return res.status(500).json({ error: 'server_error' });
  }
}

export async function resendVerification(req: Request, res: Response) {
  // TODO: 速率限制
  const { email } = req.body ?? {};
  
  if (!email) {
    audit('resend_verify_invalid_request', { ip: req.ip });
    return res.status(400).json({ error: 'invalid_request' });
  }
  
  try {
    const u = await prisma.user.findUnique({ where: { email } });
    if (!u) {
      // 不暴露存在性
      audit('resend_verify_not_found', { email, ip: req.ip });
      return res.json({ ok: true }); 
    }
    
    if (u.emailVerifiedAt) {
      audit('resend_verify_already_verified', { userId: u.id, email, ip: req.ip });
      return res.json({ ok: true });
    }
    
    // 使旧令牌失效
    await prisma.emailVerificationToken.updateMany({
      where: { userId: u.id, status: 'pending' },
      data: { status: 'expired' }
    });
    
    const token = crypto.randomUUID();
    await prisma.emailVerificationToken.create({
      data: { userId: u.id, token, expiresAt: minutesFromNow(30) }
    });
    
    const url = buildUrl(env.issuerUrl, '/verify', { token });
    await sendMailDev(u.email, 'Verify your email', `点击验证：<a href="${url}">${url}</a>`);
    
    audit('verify_resend', { userId: u.id, email, ip: req.ip });
    return res.json({ ok: true });
    
  } catch (error) {
    audit('resend_verify_error', { email, error: error instanceof Error ? error.message : String(error), ip: req.ip });
    return res.status(500).json({ error: 'server_error' });
  }
}

export async function forgotPassword(req: Request, res: Response) {
  // TODO: 速率限制
  const { email } = req.body ?? {};
  
  if (!email) {
    audit('forgot_password_invalid_request', { ip: req.ip });
    return res.status(400).json({ error: 'invalid_request' });
  }
  
  try {
    const u = await prisma.user.findUnique({ where: { email } });
    
    // 统一响应，不暴露存在性
    if (!u) { 
      audit('forgot_password_not_found', { email, ip: req.ip });
      return res.json({ ok: true }); 
    }
    
    // 使旧重置令牌失效
    await prisma.passwordResetToken.updateMany({
      where: { userId: u.id, status: 'pending' },
      data: { status: 'expired' }
    });
    
    const token = crypto.randomUUID();
    await prisma.passwordResetToken.create({
      data: { userId: u.id, token, expiresAt: minutesFromNow(30) }
    });
    
    const url = buildUrl(env.issuerUrl, '/reset-password', { token });
    await sendMailDev(u.email, 'Reset your password', `重置链接：<a href="${url}">${url}</a>`);
    
    audit('forgot_password', { userId: u.id, email, ip: req.ip });
    return res.json({ ok: true });
    
  } catch (error) {
    audit('forgot_password_error', { email, error: error instanceof Error ? error.message : String(error), ip: req.ip });
    return res.status(500).json({ error: 'server_error' });
  }
}

export async function resetPassword(req: Request, res: Response) {
  const { token, new_password } = req.body ?? {};
  
  if (!token || !new_password) {
    audit('reset_password_invalid_request', { ip: req.ip });
    return res.status(400).json({ error: 'invalid_request' });
  }
  
  // 基本密码长度检查
  if (new_password.length < 6) {
    audit('reset_password_weak', { token, ip: req.ip });
    return res.status(400).json({ error: 'password_too_short' });
  }
  
  try {
    const t = await prisma.passwordResetToken.findUnique({ 
      where: { token },
      include: { user: true }
    });
    
    if (!t || t.status !== 'pending' || t.expiresAt < new Date()) {
      audit('reset_password_fail', { token, ip: req.ip });
      return res.status(400).json({ error: 'invalid_token' });
    }
    
    const hash = await bcrypt.hash(new_password, env.passwordHashRounds);
    await prisma.$transaction([
      prisma.user.update({ 
        where: { id: t.userId }, 
        data: { passwordHash: hash }
      }),
      prisma.passwordResetToken.update({ 
        where: { token }, 
        data: { status: 'used', usedAt: new Date() }
      })
    ]);
    
    audit('reset_password_success', { userId: t.userId, email: t.user.email, ip: req.ip });
    return res.json({ ok: true });
    
  } catch (error) {
    audit('reset_password_error', { token, error: error instanceof Error ? error.message : String(error), ip: req.ip });
    return res.status(500).json({ error: 'server_error' });
  }
}

// 需要 Bearer（已实现）保护
export async function changePassword(req: Request, res: Response) {
  // claims 注入自 requireBearer
  const claims = (req as any).claims;
  if (!claims?.sub) {
    audit('change_password_unauthorized', { ip: req.ip });
    return res.status(401).json({ error: 'unauthorized' });
  }
  
  const { current_password, new_password } = req.body ?? {};
  
  if (!current_password || !new_password) {
    audit('change_password_invalid_request', { userId: claims.sub, ip: req.ip });
    return res.status(400).json({ error: 'invalid_request' });
  }
  
  // 基本密码长度检查
  if (new_password.length < 6) {
    audit('change_password_weak', { userId: claims.sub, ip: req.ip });
    return res.status(400).json({ error: 'password_too_short' });
  }
  
  try {
    const u = await prisma.user.findUnique({ where: { id: claims.sub } });
    if (!u?.passwordHash) {
      audit('change_password_no_hash', { userId: claims.sub, ip: req.ip });
      return res.status(401).json({ error: 'unauthorized' });
    }
    
    const ok = await bcrypt.compare(current_password, u.passwordHash);
    if (!ok) {
      audit('change_password_wrong_current', { userId: claims.sub, email: u.email, ip: req.ip });
      return res.status(401).json({ error: 'invalid_current_password' });
    }
    
    // 检查新密码是否与当前密码相同
    const samePassword = await bcrypt.compare(new_password, u.passwordHash);
    if (samePassword) {
      audit('change_password_same', { userId: claims.sub, email: u.email, ip: req.ip });
      return res.status(400).json({ error: 'password_unchanged' });
    }
    
    const hash = await bcrypt.hash(new_password, env.passwordHashRounds);
    await prisma.user.update({ 
      where: { id: u.id }, 
      data: { passwordHash: hash }
    });
    
    audit('change_password', { userId: u.id, email: u.email, ip: req.ip });
    return res.json({ ok: true });
    
  } catch (error) {
    audit('change_password_error', { userId: claims.sub, error: error instanceof Error ? error.message : String(error), ip: req.ip });
    return res.status(500).json({ error: 'server_error' });
  }
}
===== END src/controllers/identity.ts =====


===== BEGIN src/services/token.ts =====

// src/services/token.ts
import { env } from '../config/env.js';
import { prisma } from '../infra/prisma.js';
import crypto from 'crypto';
import { SignJWT, importPKCS8, JWTPayload } from 'jose';

export type AccessClaims = {
  jti: string; iat: number; exp: number; iss: string;
  aud: string | string[];
  sub: string;
  tenant_id: string;
  roles: string[];
  scopes: string[];
  device_id?: string | null;
  location_id?: string | null;
  acr: string;
};

function nowSec(){ return Math.floor(Date.now()/1000); }

function resolveAudience(inputAud: string | string[] | undefined, tenantId: string): string {
  if (typeof inputAud === 'string' && inputAud.trim()) return inputAud.trim();
  const prefix = (env.defaultAudPrefix || 'tymoe-service').replace(/:$/, '');
  return `${prefix}:${tenantId}`;
}

async function getActivePrivateKey(){
  const k = await prisma.key.findFirst({ where: { status: 'active' }});
  if (!k) throw new Error('no_active_key');
  const pkcs8 = k.privatePem;
  const privateKey = await importPKCS8(pkcs8, 'RS256');
  return { privateKey, kid: k.kid };
}

export async function signAccessToken(payload: {
  sub: string; tenant_id: string; roles?: string[]; scopes?: string[];
  device_id?: string|null; location_id?: string|null; acr?: string; aud?: string | string[];
}): Promise<string> {
  const iat = nowSec();
  const exp = iat + Number(env.accessTtlSec || 1800);
  const jti = crypto.randomUUID();
  const aud = resolveAudience(payload.aud, payload.tenant_id);

  const claims: AccessClaims = {
    jti, iat, exp, iss: env.issuerUrl, aud,
    sub: payload.sub, tenant_id: payload.tenant_id,
    roles: payload.roles ?? [], scopes: payload.scopes ?? [],
    device_id: payload.device_id ?? null, location_id: payload.location_id ?? null,
    acr: payload.acr ?? 'normal',
  };

  const { privateKey, kid } = await getActivePrivateKey();
  return await new SignJWT(claims as unknown as JWTPayload)
    .setProtectedHeader({ alg: 'RS256', kid })
    .setIssuer(env.issuerUrl)
    .setAudience(typeof aud === 'string' ? aud : aud[0])
    .setSubject(payload.sub)
    .setIssuedAt(iat)
    .setExpirationTime(exp)
    .sign(privateKey);
}

export async function signIdToken(payload: {
  sub: string; 
  tenant_id: string; 
  client_id: string;   // ✅ 用客户端作为 ID Token 的 aud
  nonce?: string;      // ✅ 回显授权请求的 nonce（如有）
  acr?: string;
}): Promise<string> {
  const iat = nowSec();
  const exp = iat + 300;
  const { privateKey, kid } = await getActivePrivateKey();
  const claims: JWTPayload = {
    iss: env.issuerUrl,
    aud: payload.client_id,           // ✅ OIDC 要求 aud=client_id
    sub: payload.sub,
    iat, exp,
    jti: crypto.randomUUID(),
    tenant_id: payload.tenant_id,
    acr: payload.acr ?? 'normal',
    ...(payload.nonce ? { nonce: payload.nonce } : {}), // ✅ 回显 nonce
  };
  return await new SignJWT(claims)
    .setProtectedHeader({ alg: 'RS256', kid })
    .setIssuer(env.issuerUrl).setAudience(payload.client_id)
    .setSubject(payload.sub)
    .setIssuedAt(iat).setExpirationTime(exp).sign(privateKey);
}

// ===== Refresh Token Family =====

export async function issueRefreshFamily(args: { userId?: string; deviceId?: string|null; clientId: string; tenantId?: string }){
  const id = crypto.randomUUID();
  const familyId = crypto.randomUUID();
  await prisma.refreshToken.create({
    data: {
      id, familyId, clientId: args.clientId,
      subjectUserId: args.userId ?? null,
      subjectDeviceId: args.deviceId ?? null,
      status: 'active',
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + Number(env.refreshTtlSec)*1000)
    }
  });
  return { refreshId: id, familyId };
}

export async function rotateRefreshToken(oldId: string){
  const old = await prisma.refreshToken.findUnique({ where: { id: oldId }});
  if (!old) {
    const err: any = new Error('invalid_refresh_token_not_found');
    err.code = 'not_found';
    throw err;
  }
  if (old.expiresAt && old.expiresAt < new Date()) {
    const err: any = new Error('invalid_refresh_token_expired');
    err.code = 'expired';
    throw err;
  }
  if (old.status === 'rotated') {
    const err: any = new Error('invalid_refresh_token_reuse');
    err.code = 'reuse';
    throw err;
  }
  if (old.status !== 'active') {
    const err: any = new Error('invalid_refresh_token_inactive');
    err.code = 'inactive';
    throw err;
  }

  // 旋转：旧设为 rotated，新发一个同 familyId
  await prisma.refreshToken.update({ where: { id: oldId }, data: { status: 'rotated', rotatedAt: new Date() }});
  const newId = crypto.randomUUID();
  await prisma.refreshToken.create({
    data: {
      id: newId, familyId: old.familyId, clientId: old.clientId,
      subjectUserId: old.subjectUserId, subjectDeviceId: old.subjectDeviceId,
      status: 'active',
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + Number(env.refreshTtlSec)*1000)
    }
  });
  return { newId, subject: { userId: old.subjectUserId, deviceId: old.subjectDeviceId } };
}

export async function revokeFamilyByOldReuse(oldId: string){
  const old = await prisma.refreshToken.findUnique({ where: { id: oldId }});
  if (!old) return;
  await prisma.refreshToken.updateMany({ where: { familyId: old.familyId }, data: { status: 'revoked', revokedAt: new Date(), revokeReason: 'reuse_detected' }});
}
===== END src/services/token.ts =====


===== BEGIN src/services/mailer.ts =====

// src/services/mailer.ts
import { env } from '../config/env.js';

export async function sendMailDev(to: string, subject: string, html: string) {
  // 生产可接入 SMTP，这里开发期直接 log
  console.log(`[DEV MAIL] to=${to} subject="${subject}" from=${env.mailFrom}`);
  console.log('=== EMAIL CONTENT START ===');
  console.log(html);
  console.log('=== EMAIL CONTENT END ===');
  console.log('');
  
  // 模拟异步发送
  return Promise.resolve({ success: true, messageId: Date.now().toString() });
}
===== END src/services/mailer.ts =====


===== BEGIN src/services/tenant.ts =====

import { prisma } from '../infra/prisma.js';
import { env } from '../config/env.js';

export interface TenantAuthContext {
  clientId: string;
  tenantId: string;
  requestedScopes: string[];
  requestedAud?: string;
}

export interface ValidatedTenantAuth {
  tenantId: string;
  allowedScopes: string[];
  finalAud: string;
}

/**
 * R5: 多租户强隔离验证
 */
export async function validateTenantAuthorization(context: TenantAuthContext): Promise<ValidatedTenantAuth> {
  // 1. 查找客户端的租户配置
  const tenantClient = await prisma.tenantClient.findUnique({
    where: {
      clientId_tenantId: {
        clientId: context.clientId,
        tenantId: context.tenantId
      }
    }
  });

  if (!tenantClient) {
    throw new Error('unauthorized_tenant');
  }

  // 2. 验证 scope 权限
  const requestedScopes = context.requestedScopes;
  const allowedScopes = tenantClient.allowedScopes;
  
  // 检查请求的 scope 是否都在允许范围内
  const unauthorizedScopes = requestedScopes.filter(scope => !allowedScopes.includes(scope));
  if (unauthorizedScopes.length > 0) {
    throw new Error(`unauthorized_scope: ${unauthorizedScopes.join(', ')}`);
  }

  // 3. 验证和构造 audience
  let finalAud: string;

  if (context.requestedAud) {
    // 检查请求的 aud 是否在允许的前缀范围内
    const isAllowed = tenantClient.allowedAudPrefixes.some(prefix => 
      context.requestedAud!.startsWith(prefix)
    );
    
    if (!isAllowed) {
      throw new Error('unauthorized_audience');
    }
    
    // 确保 aud 包含租户 ID
    if (!context.requestedAud.includes(`:${context.tenantId}`)) {
      throw new Error('audience_missing_tenant');
    }
    
    finalAud = context.requestedAud;
  } else {
    // 使用默认 aud
    if (tenantClient.defaultAud) {
      finalAud = tenantClient.defaultAud;
    } else {
      // 构造默认格式：prefix:tenant_id
      const defaultPrefix = tenantClient.allowedAudPrefixes[0] || env.defaultAudPrefix;
      finalAud = `${defaultPrefix}:${context.tenantId}`;
    }
  }

  // 4. 如果启用了严格 audience 验证
  if (env.tenantEnforceAud) {
    if (!finalAud.includes(`:${context.tenantId}`)) {
      throw new Error('audience_tenant_mismatch');
    }
  }

  return {
    tenantId: context.tenantId,
    allowedScopes: requestedScopes, // 返回验证通过的 scope
    finalAud
  };
}

/**
 * 获取用户可用的租户和权限
 */
export async function getUserTenantScopes(userId: string, clientId: string): Promise<string[]> {
  // 获取用户信息
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { tenantId: true, roles: true }
  });

  if (!user) {
    return [];
  }

  // 获取该客户端在用户租户下的配置
  const tenantClient = await prisma.tenantClient.findUnique({
    where: {
      clientId_tenantId: {
        clientId: clientId,
        tenantId: user.tenantId
      }
    }
  });

  if (!tenantClient) {
    return [];
  }

  // 根据用户角色过滤可用 scope（这里可以扩展更复杂的权限逻辑）
  let availableScopes = tenantClient.allowedScopes;
  
  // 示例：管理员角色可以访问所有 scope
  if (!user.roles.includes('admin')) {
    // 普通用户移除管理相关 scope
    availableScopes = availableScopes.filter(scope => 
      !scope.includes('admin') && !scope.includes('manage')
    );
  }

  return availableScopes;
}

/**
 * 创建或更新租户客户端配置
 */
export async function createTenantClient(config: {
  clientId: string;
  tenantId: string;
  allowedAudPrefixes: string[];
  allowedScopes: string[];
  defaultAud?: string;
}) {
  return await prisma.tenantClient.upsert({
    where: {
      clientId_tenantId: {
        clientId: config.clientId,
        tenantId: config.tenantId
      }
    },
    create: config,
    update: {
      allowedAudPrefixes: config.allowedAudPrefixes,
      allowedScopes: config.allowedScopes,
      defaultAud: config.defaultAud
    }
  });
}

/**
 * 验证客户端是否有权访问指定租户
 */
export async function validateClientTenantAccess(clientId: string, tenantId: string): Promise<boolean> {
  const count = await prisma.tenantClient.count({
    where: {
      clientId,
      tenantId
    }
  });
  
  return count > 0;
}
===== END src/services/tenant.ts =====


===== BEGIN src/middleware/bearer.ts =====

import { Request, Response, NextFunction } from 'express';
import { importJWK, jwtVerify } from 'jose';
import { prisma } from '../infra/prisma.js';
import { env } from '../config/env.js';

export async function requireBearer(req: Request, res: Response, next: NextFunction) {
  const auth = req.headers.authorization || '';
  const [scheme, token] = auth.split(' ');
  if (scheme !== 'Bearer' || !token) {
    return res.status(401).json({ error: 'invalid_token' });
  }

  try {
    // 解析JWT header获取kid
    const [headerB64] = token.split('.');
    if (!headerB64) {
      return res.status(401).json({ error: 'invalid_token' });
    }
    
    const header = JSON.parse(Buffer.from(headerB64, 'base64url').toString());
    const kid = header.kid as string | undefined;
    if (!kid) {
      return res.status(401).json({ error: 'invalid_token' });
    }

    // 根据kid查找公钥
    const keyRecord = await prisma.key.findUnique({ 
      where: { kid },
      select: { publicJwk: true, status: true }
    });
    
    if (!keyRecord || keyRecord.status === 'retired') {
      return res.status(401).json({ error: 'invalid_token' });
    }

    // 计算允许的受众
    function getAllowedAudiences(): string[] {
      const list = (process.env.ALLOWED_AUDIENCES || '')
        .split(',')
        .map(s => s.trim())
        .filter(Boolean);
      if (list.length) return list;
      // 兜底：只允许我们自己的前缀
      return [env.defaultAudPrefix || 'tymoe-service'];
    }

    // 使用jose验证JWT，增加issuer和audience校验
    const publicKey = await importJWK(keyRecord.publicJwk as any, 'RS256');
    const { payload: claims } = await jwtVerify(token, publicKey, {
      algorithms: ['RS256'],
      issuer: env.issuerUrl.replace(/\/+$/, ''),   // 规范化，去掉尾斜杠
      audience: getAllowedAudiences(),            // 限制 aud
      clockTolerance: 30                          // ✅ 30 秒时钟容错
    });
    
    (req as any).claims = claims;
    next();

  } catch (e: any) {
    return res.status(401).json({ error: 'invalid_token', detail: e?.message });
  }
}
===== END src/middleware/bearer.ts =====


===== BEGIN src/middleware/audit.ts =====

// src/middleware/audit.ts
import fs from 'fs';
import { env } from '../config/env.js';

export function audit(action: string, detail: any){
  try{
    if (!env.auditToFile) return;
    const line = JSON.stringify({ at: new Date().toISOString(), action, detail }) + '\n';
    fs.appendFileSync(env.auditFilePath, line);
  }catch (_e){}
}
===== END src/middleware/audit.ts =====


===== BEGIN src/infra/keystore.ts =====

// src/infra/keystore.ts
import { prisma } from './prisma.js';
import { env } from '../config/env.js';
import { createHash, generateKeyPairSync } from 'crypto';
import { exportJWK } from 'jose';

type DbKey = {
  kid: string; type: string; status: 'active'|'grace'|'retired';
  privatePem: string; publicJwk: any;
  createdAt: Date; activatedAt: Date|null; retiredAt: Date|null;
};

function computeJwksEtag(keys: any[]): string {
  const raw = JSON.stringify(keys.map(k => ({ kid: k.kid, e: k.e, n: k.n, use: k.use })));
  const h = createHash('sha1').update(raw).digest('hex');
  return `"jwks-${h}"`;
}

export async function getActiveKey(): Promise<DbKey|null> {
  const k = await prisma.key.findFirst({ where: { status: 'active' }});
  return k as any;
}

export async function getGraceKeys(): Promise<DbKey[]> {
  const ks = await prisma.key.findMany({ where: { status: 'grace' }});
  return ks as any;
}

export async function ensureOneActiveKey(): Promise<void> {
  const active = await getActiveKey();
  if (active) return;
  await rotateKey(); // 生成一把
}

export async function rotateKey(): Promise<DbKey> {
  // 1) 旧 active → grace
  const old = await getActiveKey();
  if (old) {
    await prisma.key.update({ where: { kid: old.kid }, data: { status: 'grace', activatedAt: old.activatedAt ?? new Date() }});
  }
  // 2) 生成新 RSA（2048）
  const { privateKey, publicKey } = generateKeyPairSync('rsa', { modulusLength: 2048 });
  const privatePem = privateKey.export({ type: 'pkcs8', format: 'pem' }).toString();
  const jwk = await exportJWK(publicKey as any);
  const kid = `kid-${Date.now()}`;
  const publicJwk = { ...jwk, kid, alg: 'RS256', use: 'sig' };

  const created = await prisma.key.create({
    data: { kid, type: 'RSA', status: 'active', privatePem, publicJwk, createdAt: new Date(), activatedAt: new Date() }
  });

  // 3) 只保留一把 grace，更多的设为 retired
  const graces = await getGraceKeys();
  if (graces.length > 1) {
    const sorted = graces.sort((a,b)=> (a.activatedAt?.getTime()||0)-(b.activatedAt?.getTime()||0));
    for (let i=0;i<sorted.length-1;i++){
      await prisma.key.update({ where: { kid: sorted[i].kid }, data: { status: 'retired', retiredAt: new Date() }});
    }
  }
  return created as any;
}

export async function buildJwksWithEtag(){
  const active = await getActiveKey();
  const graces = await getGraceKeys();
  const keys = [active, ...graces].filter(Boolean).map(k => (k as any).publicJwk);
  const etag = computeJwksEtag(keys);
  return { jwks: { keys }, etag };
}
===== END src/infra/keystore.ts =====


===== BEGIN src/infra/prisma.ts =====

import { PrismaClient } from '@prisma/client';
export const prisma = new PrismaClient();

===== END src/infra/prisma.ts =====


===== BEGIN src/config/env.ts =====

// src/config/env.ts
export const env = {
  nodeEnv: process.env.NODE_ENV ?? 'development',
  issuerUrl: process.env.ISSUER_URL ?? 'http://localhost:8080/',
  port: Number(process.env.PORT ?? '8080'),

  // Token TTL（确保为 number）
  accessTtlSec: Number(process.env.ACCESS_TOKEN_TTL_SECONDS ?? '1800'),
  refreshTtlSec: Number(process.env.REFRESH_TOKEN_TTL_SECONDS ?? '2592000'), // 30d

  // 多租户 & 受众
  defaultAudPrefix: process.env.DEFAULT_AUD_PREFIX ?? 'tymoe-service', // 兜底前缀
  tenantEnforceAud: process.env.TENANT_ENFORCE_AUD !== 'false',        // 默认启用

  // Rate Limit（保留你现有的值；没有就给默认）
  rateLoginPerMin: Number(process.env.RATE_LOGIN_PER_MIN ?? '5'),
  rateTokenPerMin: Number(process.env.RATE_TOKEN_PER_MIN ?? '25'),

  // Introspection 机密客户端（可放 env 或 DB；这里先放 env 以简化）
  introspectClientId: process.env.INTROSPECT_CLIENT_ID ?? 'gateway',
  introspectClientSecret: process.env.INTROSPECT_CLIENT_SECRET ?? 'gateway-secret',

  // 审计落地（文件或DB，这里两者都开，至少保证有一条线）
  auditToFile: process.env.AUDIT_TO_FILE !== 'false',
  auditFilePath: process.env.AUDIT_FILE_PATH ?? './audit.log',

  // JWKS ETag 缓存
  jwksMaxAgeSec: Number(process.env.JWKS_MAX_AGE_SEC ?? '3600'),

  // Session secret
  sessionSecret: process.env.SESSION_SECRET ?? 'dev-session-secret-key',

  // Legacy JWT key for backwards compatibility
  jwtPrivateKey: process.env.JWT_PRIVATE_KEY ?? '',
  
  // Identity Management
  mailFrom: process.env.MAIL_FROM ?? 'no-reply@tymoe.local',
  defaultTenantId: process.env.DEFAULT_TENANT_ID ?? 'tenant-dev',
  passwordHashRounds: parseInt(process.env.PASSWORD_HASH_ROUNDS ?? '10', 10),
} as const;
===== END src/config/env.ts =====


===== BEGIN src/routes/oidc.ts =====

import { Router } from 'express';
import { discovery, jwks, token, revoke, userinfo, getAuthorize, getLogin, postLogin, logout, introspect } from '../controllers/oidc.js';
import { requireBearer } from '../middleware/bearer.js';
import { limitLogin, limitToken } from '../middleware/rate.js';
import { csrfProtection } from '../infra/csrf.js';

const r = Router();

r.get('/.well-known/openid-configuration', discovery);
r.get('/jwks.json', jwks);

// R4: 浏览器流 + CSRF 保护
r.get('/oauth/authorize', getAuthorize);
r.get('/login', csrfProtection, getLogin);
r.post('/login', limitLogin, csrfProtection, postLogin);
r.get('/logout', logout);

// R4: Token/撤销 + 速率限制
r.post('/oauth/token', limitToken, token);
r.post('/oauth/revoke', revoke);

// R4: Token Introspection
r.post('/oauth/introspect', introspect);

// Userinfo 需要 Bearer
r.get('/userinfo', requireBearer, userinfo);

export default r;
===== END src/routes/oidc.ts =====


===== BEGIN src/routes/identity.ts =====

import { Router } from 'express';
import { 
  register, 
  verifyEmail, 
  resendVerification, 
  forgotPassword, 
  resetPassword, 
  changePassword 
} from '../controllers/identity.js';
import { requireBearer } from '../middleware/bearer.js';

const router = Router();

// 注册新用户
router.post('/register', register);

// 邮箱验证（支持 GET 和 POST）
router.get('/verify', verifyEmail);
router.post('/verify', verifyEmail);

// 重发验证邮件
router.post('/verify/resend', resendVerification);

// 忘记密码
router.post('/forgot-password', forgotPassword);

// 重置密码
router.post('/reset-password', resetPassword);

// 修改密码（需要认证）
router.post('/change-password', requireBearer, changePassword);

export default router;
===== END src/routes/identity.ts =====


===== BEGIN src/index.ts =====

import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import pino from 'pino';
import pinoHttp from 'pino-http';
import { env } from './config/env.js';
import oidcRoutes from './routes/oidc.js';
import identityRoutes from './routes/identity.js';
import { prisma } from './infra/prisma.js';
import { sessionMiddleware } from './infra/session.js';
import { registry } from './infra/metrics.js';

// 创建 logger
export const logger = pino({
  level: env.nodeEnv === 'development' ? 'debug' : 'info',
  transport: env.nodeEnv === 'development' ? {
    target: 'pino-pretty',
    options: { colorize: true }
  } : undefined,
});

const app = express();

// 中间件顺序很重要
app.use(helmet());
app.use(pinoHttp({ logger }));
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: false })); // 解析 login 表单
app.use(cors());
app.use(sessionMiddleware);

app.get('/healthz', (_req, res) => res.json({ ok: true }));

// Prometheus metrics端点
app.get('/metrics', async (_req, res) => {
  res.set('Content-Type', registry.contentType);
  res.send(await registry.metrics());
});

app.use(oidcRoutes);
app.use(identityRoutes);

app.use((err: any, _req: any, res: any, _next: any) => {
  console.error(err);
  res.status(500).json({ error: 'server_error', detail: err?.message });
});

app.listen(env.port, () => {
  console.log(`auth-service listening on :${env.port}`);
});

===== END src/index.ts =====


===== BEGIN prisma/schema.prisma =====

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                         String   @id @default(uuid())
  email                      String   @unique
  // 由明文 password 迁移为哈希
  passwordHash               String?
  // 可选：保留 legacy 明文字段，迁移后清空
  password                   String?  @map("password_legacy")
  tenantId                   String
  roles                      String[] @default([])
  emailVerifiedAt            DateTime?
  createdAt                  DateTime @default(now())
  updatedAt                  DateTime @updatedAt
  
  // Relations
  emailVerificationTokens    EmailVerificationToken[]
  passwordResetTokens        PasswordResetToken[]
}

model Client {
  id           String   @id       // client_id
  name         String
  redirectUris Json     // string[] of allowed redirect URIs
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model RefreshToken {
  id               String   @id
  familyId         String
  subjectUserId    String?
  subjectDeviceId  String?
  clientId         String
  status           String   @default("active") // active|rotated|revoked
  createdAt        DateTime @default(now())
  expiresAt        DateTime
  rotatedAt        DateTime?
  revokedAt        DateTime?
  revokeReason     String?

  @@index([familyId])
  @@index([subjectUserId])
  @@index([status])
}

model AuthorizationCode {
  id                   String   @id @default(uuid())
  clientId             String
  redirectUri          String
  codeChallenge        String
  codeChallengeMethod  String   @default("S256")
  scope                String?
  state                String?
  nonce                String?
  subjectUserId        String?
  tenantId             String?
  createdAt            DateTime @default(now())
  expiresAt            DateTime
  used                 Boolean  @default(false)
  usedAt               DateTime?

  @@index([clientId])
  @@index([subjectUserId])
  @@index([expiresAt])
}

model Key {
  kid          String   @id
  type         String   // 'RSA'
  status       String   // 'active' | 'grace' | 'retired'
  privatePem   String   // PKCS8 PEM（开发期可明文；生产建议加密）
  publicJwk    Json
  createdAt    DateTime @default(now())
  activatedAt  DateTime?
  retiredAt    DateTime?

  @@index([status])
}

model TenantClient {
  id                 String   @id @default(uuid())
  clientId           String
  tenantId           String
  allowedAudPrefixes String[] // 例如: ["tymoe-service:mopai", "tymoe-service:ploml"]
  allowedScopes      String[] // 例如: ["openid","profile"]
  defaultAud         String?  // 例如: "tymoe-service:mopai:tenant-dev"
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@unique([clientId, tenantId])
}

model EmailVerificationToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  status    String   @default("pending") // pending | used | expired
  createdAt DateTime @default(now())
  expiresAt DateTime
  usedAt    DateTime?
  
  user      User     @relation(fields: [userId], references: [id])
  
  @@index([userId])
  @@index([status, expiresAt])
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  status    String   @default("pending") // pending | used | expired
  createdAt DateTime @default(now())
  expiresAt DateTime
  usedAt    DateTime?
  
  user      User     @relation(fields: [userId], references: [id])
  
  @@index([userId])
  @@index([status, expiresAt])
}

model AuditLog {
  id          String   @id @default(uuid())
  at          DateTime @default(now())
  ip          String?
  userAgent   String?
  actorUserId String?
  action      String   // login_success / login_fail / authorize / token_issue / token_refresh / refresh_reuse / revoke / introspect / jwks_rotate / jwks_retire …
  subject     String?  // token_id / code_id / client_id / tenant_id …
  detail      Json?
}

===== END prisma/schema.prisma =====


===== BEGIN package.json =====

{
  "name": "auth-service-starter",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/index.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev --name init",
    "migrate": "prisma migrate deploy",
    "lint": "eslint .",
    "rotate:key": "tsx src/scripts/rotate-key.ts",
    "retire:keys": "tsx src/scripts/retire-keys.ts",
    "e2e": "node e2e/run-all.mjs --group=R5",
    "e2e:all": "node e2e/run-all.mjs"
  },
  "dependencies": {
    "@prisma/client": "^5.17.0",
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-session": "^2.0.49",
    "bcryptjs": "^3.0.2",
    "cookie-session": "^2.1.1",
    "cors": "^2.8.5",
    "csurf": "^1.11.0",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^8.0.1",
    "helmet": "^7.1.0",
    "jose": "^6.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "pino": "^9.9.0",
    "pino-http": "^10.5.0",
    "prom-client": "^15.1.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/csurf": "^1.11.5",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/morgan": "^1.9.9",
    "@types/node": "^20.12.7",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "eslint": "^9.8.0",
    "pino-pretty": "^13.1.1",
    "prisma": "^5.17.0",
    "tsx": "^4.16.2",
    "typescript": "^5.4.5"
  }
}

===== END package.json =====


===== BEGIN .env.example =====

ISSUER_URL=http://localhost:8080
ACCESS_TOKEN_TTL_SECONDS=1800
REFRESH_TOKEN_TTL_SECONDS=2592000
DEFAULT_AUD_PREFIX=tymoe-service
TENANT_ENFORCE_AUD=true
INTROSPECT_CLIENT_ID=gateway
INTROSPECT_CLIENT_SECRET=gateway-secret
JWKS_MAX_AGE_SEC=3600

# Identity Management
DEFAULT_TENANT_ID=tenant-dev
PASSWORD_HASH_ROUNDS=10

# Email sending - development mode: print URL to console
MAIL_FROM=no-reply@tymoe.com
===== END .env.example =====


===== PACKAGE INFO =====

Generated: $(date)
Branch: auth-service-v0.2.5
Commit: $(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

===== END PACKAGE INFO =====
